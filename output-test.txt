#INFO: **** input file is /Users/jaydenl/Dev/ASDRP/QCHEM/PySCF-UI/stream.py ****
import streamlit as st
import streamlit.components.v1 as components
from pyscf import gto, scf
from streamlit.runtime.scriptrunner import add_script_run_ctx
import threading
import time
from stmol import *
import py3Dmol
from rdkit import Chem
from rdkit.Chem import rdDetermineBonds
from rdkit.Chem.rdmolfiles import MolFromXYZFile
from rdkit.Chem import Descriptors, Draw, AllChem
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from collections import defaultdict
import altair as alt
import os
from pyscf.hessian import thermo
from streamlit_extras.row import row
from utils import getAtomicToMoleculeName
# R^2
from sklearn.metrics import r2_score
import requests

api_url = "http://0.0.0.0:8000/calculate"
moleculeNames = getAtomicToMoleculeName()
trend_threshold = 0.95

if 'queue' not in st.session_state:
    st.session_state['queue'] = []
if 'results' not in st.session_state:
    st.session_state['results'] = []
if 'computing' not in st.session_state:
    st.session_state['computing'] = False

# get all files in directory names precomputed_molecules:
precomputed_molecules = list(map(lambda x: x.split(
    ".")[0], os.listdir("precomputed_molecules")))


def compute_pyscf(atom, basis_option, verbose_option, temperature, pressure):
    # print(atom)
    # print(basis_option)
    # print(verbose_option)
    mol = gto.Mole()
    mol.atom = atom
    mol.basis = basis_option
    # mol.verbose = verbose_option
    mol.verbose = int(verbose_option[0])
    mol.output = 'output-test.txt'
    mol.build()

    # mf = scf.RHF(mol)
    # mf.kernel()
    mf =mol.UHF().run()
    hessian = mf.Hessian().kernel()
    harmanalysis = thermo.harmonic_analysis(mf.mol, hessian)
    thermo_info =  thermo.thermo(mf, harmanalysis['freq_au'], temperature, pressure)
    
    outputFile = open("output-test.txt", "r")
    # Extract energy and time information
    time = None
    hessian_time = None
    energy = None
    for line in outputFile.readlines():
        if line.startswith("    CPU time for SCF"):
            time = float(line.split(" ")[-2])

        elif line.startswith("converged SCF energy = "):
            energy = float([i for i in line.split() if i != ''][4])
        elif line.startswith("    CPU time for UHF hessian"):
            hessian_time = float(line.split(" ")[-2])
    
    #Helmholtz Free Energy
    F_elec = (thermo_info['E_elec'][0] - temperature * thermo_info['S_elec' ][0], 'Eh')
    F_trans = (thermo_info['E_trans'][0] - temperature * thermo_info['S_trans'][0], 'Eh')
    F_rot = (thermo_info['E_rot'][0] - temperature * thermo_info['S_rot'][0], 'Eh')
    F_vib = (thermo_info['E_vib'][0] - temperature * thermo_info['S_vib'][0], 'Eh')
    F_tot = (F_elec[0] + F_trans[0] + F_rot[0] + F_vib[0], 'Eh') 
    
    #Massieu Potential/Helmholtz Free Entropy
    Φ_elec = (F_elec[0]/(-1*temperature), 'Eh/K')
    Φ_trans = (F_trans[0]/(-1*temperature), 'Eh/K')
    Φ_rot = (F_rot[0]/(-1*temperature), 'Eh/K')
    Φ_vib = (F_vib[0]/(-1*temperature), 'Eh/K')
    Φ_tot = (F_tot[0]/(-1*temperature), 'Eh/K')    
    
    #Planck Potential/Gibbs Free Entropy
    Ξ_elec = (thermo_info['G_elec'][0]/(-1*temperature), 'Eh/K')
    Ξ_trans = (thermo_info['G_trans'][0]/(-1*temperature), 'Eh/K')
    Ξ_rot = (thermo_info['G_rot'][0]/(-1*temperature), 'Eh/K')
    Ξ_vib = (thermo_info['G_vib'][0]/(-1*temperature), 'Eh/K')
    Ξ_tot = (thermo_info['G_tot'][0]/(-1*temperature), 'Eh/K')   
    
    data = {
        # 'energy': energy,
        'Runtime': time,
        'Hessian Runtime': hessian_time,
        'Converged SCF-HF Nuclear Energy (Ha)': mf.energy_nuc(),
        'Converged SCF-HF Electronic Energy (Ha)': mf.energy_elec(),
        'Converged SCF-HF Total Energy (Ha)': mf.energy_tot(),
        # thermodynamic data
        # Heat Capacity
        'Constant Volume Heat Capacity (Ha/K)': thermo_info['Cv_tot'][0],
        'Constant Pressure Heat Capacity (Ha/K)': thermo_info['Cp_tot'][0],
        'Zero-Point Energy (Ha)': thermo_info['ZPE'][0],
        '0K Internal Energy (Ha)': thermo_info['E_0K'][0],
        'Internal Energy (at given T) (Ha)': thermo_info['E_tot'][0],
            'Electronic Internal Energy (Ha)': thermo_info['E_elec'][0],
            'Vibrational Internal Energy (Ha)': thermo_info['E_vib'][0],
            'Translational Internal Energy (Ha)': thermo_info['E_trans'][0],
            'Rotational Internal Energy (Ha)': thermo_info['E_rot'][0],
        # enthalpy
        'Enthalpy (Ha)': thermo_info['H_tot'][0],
            'Electronic Enthalpy (Ha)': thermo_info['H_elec'][0],
            'Vibrational Enthalpy (Ha)': thermo_info['H_vib'][0],
            'Translational Enthalpy (Ha)': thermo_info['H_trans'][0],
            'Rotational Enthalpy (Ha)': thermo_info['H_rot'][0],
        # gibbs free energy
        'Gibbs Free Energy (Ha)': thermo_info['G_tot'][0],
            'Electronic Gibbs Free Energy (Ha)': thermo_info['G_elec'][0],
            'Vibrational Gibbs Free Energy (Ha)': thermo_info['G_vib'][0],
            'Translational Gibbs Free Energy (Ha)': thermo_info['G_trans'][0],
            'Rotational Gibbs Free Energy (Ha)': thermo_info['G_rot'][0],
        # Helmholtz free energy
        'Helmholtz Free Energy (Ha)': F_tot[0],
            'Electronic Helmholtz Free Energy (Ha)': F_elec[0],
            'Vibrational Helmholtz Free Energy (Ha)': F_vib[0],
            'Translational Helmholtz Free Energy (Ha)': F_trans[0],
            'Rotational Helmholtz Free Energy (Ha)': F_rot[0],
        # Entropy
        'Entropy (Ha/K)': thermo_info['S_tot'][0],
            'Electronic Entropy (Ha/K)': thermo_info['S_elec'][0],
            'Vibrational Entropy (Ha/K)': thermo_info['S_vib'][0],
            'Translational Entropy (Ha/K)': thermo_info['S_trans'][0],
            'Rotational Entropy (Ha/K)': thermo_info['S_rot'][0],
        # Massieu Potential/Helmholtz Free Entropy
        'Massieu Potential/Helmholtz Free Potential (Ha/K)': Φ_tot[0],
            'Electronic Massieu Potential/Helmholtz Free Potential (Ha/K)': Φ_elec[0],
            'Vibrational Massieu Potential/Helmholtz Free Potential (Ha/K)': Φ_vib[0],
            'Translational Massieu Potential/Helmholtz Free Potential (Ha/K)': Φ_trans[0],
            'Rotational Massieu Potential/Helmholtz Free Potential (Ha/K)': Φ_rot[0],
        # Planck Potential/Gibbs Free Entropy
        'Planck Potential/Gibbs Free Potential (Ha/K)': Ξ_tot[0],
            'Electronic Planck Potential/Gibbs Free Potential (Ha/K)': Ξ_elec[0],
            'Vibrational Planck Potential/Gibbs Free Potential (Ha/K)': Ξ_vib[0],
            'Translational Planck Potential/Gibbs Free Potential (Ha/K)': Ξ_trans[0],
            'Rotational Planck Potential/Gibbs Free Potential (Ha/K)': Ξ_rot[0],
    }

    return data


def getMoleculeName(atom):
    d = {}
    for line in atom.split("\n"):
        try:
            name = line.split()[0]
            if name in d:
                d[name] += 1
            else:
                d[name] = 1
        except:
            pass
    name = ""
    for key in d:
        name += key + str(d[key])
    return name


# Streamlit layout
st.title("PySCF")

# Function to process the uploaded text file


def process_text_file(uploaded_file):
    if uploaded_file is not None:
        # Read the contents of the file
        text_contents = uploaded_file.getvalue().decode("utf-8")
        return text_contents
    else:
        return None


def addToQueue(atom, basis):
    st.session_state['queue'].append((atom, basis))


tabDatabase, tabTextInput, tabFileInput = st.tabs(
    ["Database", "Text Input", "File Input"])

basis_option = st.selectbox(
    "Basis", ["cc-pVTZ", "cc-pVDZ", "cc-pVQZ", "cc-pV5Z", "sto-3g"])
verbose_option = st.selectbox("Verbose", index=2, options=[
                              "3, energy only", "4, cycles and energy", "5, cycles energy and runtime", "9, max"])
# verbose_option = st.slider("Verbose", min_value=0, max_value=9, value=2)

#Second Input (NEW) - Pressure of the system
# pressure = 101325 #in Pascals (Pa), 101325 Pa = 1 atm
#Third Input (NEW) - Temperature of the system
# temperature = 298.15 #in K, 298.15K = room temperature (25 degrees Celsius) 
thermo_row = row(2)
temp = thermo_row.number_input("Temperature (K)", min_value=0.0, value=298.15)
press = thermo_row.number_input("Pressure (Pa)", min_value=0.0, value=101325.0)

with tabDatabase:
    selectedMolecule = st.selectbox(
        'Search Molecule Database', precomputed_molecules)
    if st.button('Add to Queue', use_container_width=True, key="db"):
        if selectedMolecule:
            parseDatafile = open(
                "precomputed_molecules/" + selectedMolecule + ".geom.txt", "r").readlines()[4:]
            parseDatafile = "\n".join(parseDatafile[:-1])
            addToQueue(parseDatafile, basis_option)
        else:
            st.warning(
                "Please select a molecule using dropdown menu or inputting a text file.")

with tabTextInput:
    # Create a Streamlit button which gives example
    with st.expander("See Example Input"):
        st.write("C 0.0000000 0.0000000 0.0000000")
        st.write("H 0.6311940 0.6311940 0.6311940")
        st.write("H -0.6311940 -0.6311940 0.6311940")
        st.write("H -0.6311940 0.6311940 -0.6311940")
        st.write("H 0.6311940 -0.6311940 -0.631194")
    # Fills xyz_input text area to the contents of the uploaded file
    xyz_input = st.text_area("XYZ Input", key="textxyz")

    if st.button('Add to Queue', use_container_width=True, key="text"):
        if xyz_input:
            addToQueue(xyz_input, basis_option)
        else:
            st.warning(
                "Please provide an XYZ input using the text box or inputting a text file.")

with tabFileInput:
    # Create a Streamlit button which gives example
    with st.expander("See Example Input"):
        st.write("C 0.0000000 0.0000000 0.0000000")
        st.write("H 0.6311940 0.6311940 0.6311940")
        st.write("H -0.6311940 -0.6311940 0.6311940")
        st.write("H -0.6311940 0.6311940 -0.6311940")
        st.write("H 0.6311940 -0.6311940 -0.631194")
    # Display file uploader for a single text file and processes it
    uploaded_file = st.file_uploader("Upload a XYZ input", type=["txt"])
    text_contents = process_text_file(uploaded_file)
    xyz_input = st.text_area(
        "XYZ Input", value=text_contents, key="filexyz") if text_contents else None
    if st.button('Add to Queue', use_container_width=True, key="filequeue"):
        if text_contents:
            addToQueue(text_contents, basis_option)
        else:
            st.warning(
                "Please provide an XYZ input using file uploader")

col1, col2, col3, col4 = st.columns(4, gap="small")

# if col1.button("Add to Queue"):
#     if xyz_input:
#         addToQueue(xyz_input)
#     else:
#         st.warning(
#             "Please provide an XYZ input using the text box or inputting a text file.")

# Computes only if something is added to the queue; grayed out otherwise
compute_disabled = len(st.session_state['queue']) == 0
if st.button("Compute", disabled=compute_disabled, type="primary", use_container_width=True) or st.session_state['computing'] == True:
    if len(st.session_state['queue']) > 0:
        with st.spinner("Computing " + getMoleculeName(st.session_state['queue'][0][0]) + "..."):
            st.session_state['computing'] = True
            atom = st.session_state['queue'][0][0]
            basis = st.session_state['queue'][0][1]
            st.session_state['queue'].pop(0)
            # st.write("Computing...")
            # progress_text = "Computing..."
            # my_bar = st.progress(0, text=progress_text)

            # for percent_complete in range(100):
            #     time.sleep(0.01)
            #     my_bar.progress(percent_complete + 1, text=progress_text)
            # time.sleep(1)
            # my_bar.empty()

            # Delete empty lines
            parsed = [line for line in atom.splitlines() if line.strip() != ""]
            xyz = "\n".join(parsed)
            mol = f"{len(parsed)}\nname\n{str(xyz)}"

            # output xyz into molecule.xyz file
            with open('molecule.xyz', 'w') as f:
                f.write(f"{len(parsed)}\nhi\n{str(xyz)}")

            raw_mol = MolFromXYZFile('molecule.xyz')
            rdkit_mol = Chem.Mol(raw_mol)
            rdDetermineBonds.DetermineBonds(rdkit_mol, charge=0)
            tmpmol = Chem.AddHs(rdkit_mol)
            AllChem.EmbedMolecule(tmpmol)
            smiles = Chem.MolToSmiles(tmpmol)

            data = compute_pyscf(
                atom, basis, verbose_option, temp, press)
            
            # tdict = {"atom": atom, "basis_option": basis, "verbose_option": verbose_option, "temperature": temp, "pressure": press}
            # response = requests.post(api_url, params=tdict)
            
            # if response.status_code == 200:
            #     data = response.json()
            #     print("Yay, it worked!")
            # else:
            #     print(f"Error: {response.status_code} - {response.text}")   
            data['Atoms'] = rdkit_mol.GetNumAtoms()
            data['Bonds'] = rdkit_mol.GetNumBonds()
            data['Rings'] = rdkit_mol.GetRingInfo().NumRings()
            data['Weight'] = Descriptors.MolWt(rdkit_mol)
            data['Molecule'] = mol
            data['Rdkit Molecule'] = rdkit_mol
            data['Basis'] = basis
            data['Molecule Name'] = getMoleculeName(atom)
            data['Smiles'] = smiles
            
            st.session_state['results'].append(data)
            st.rerun()
            
    elif st.session_state['computing'] == True:
        st.session_state['computing'] = False
    else:
        st.warning("Please add an XYZ input to the queue.")

if 'queue' in st.session_state:
    st.subheader("Queue")
    for queue_item in st.session_state['queue']:
        st.write(f"{getMoleculeName(queue_item[0])} | {queue_item[1]}")


tab1, tab2, tab3 = st.tabs(['Results', 'View Graphs', 'View Logs'])

with tab1:
    if 'results' in st.session_state:
        st.subheader("Results")
        for result_item in st.session_state['results']:
            data = result_item
            energy = {
                'Internal Energy (E - Ha)':[data['Internal Energy (at given T) (Ha)'],data['Electronic Internal Energy (Ha)'],data['Vibrational Internal Energy (Ha)'],data['Translational Internal Energy (Ha)'],data['Rotational Internal Energy (Ha)']],
                'Helmholtz Free Energy (F - Ha)':[data['Helmholtz Free Energy (Ha)'],data['Electronic Helmholtz Free Energy (Ha)'],data['Vibrational Helmholtz Free Energy (Ha)'],data['Translational Helmholtz Free Energy (Ha)'],data['Rotational Helmholtz Free Energy (Ha)']],
                'Gibbs Free Energy (G - Ha)':[data['Gibbs Free Energy (Ha)'],data['Electronic Gibbs Free Energy (Ha)'],data['Vibrational Gibbs Free Energy (Ha)'],data['Translational Gibbs Free Energy (Ha)'],data['Rotational Gibbs Free Energy (Ha)']],
                'Enthalpy (H - Ha)':[data['Enthalpy (Ha)'],data['Electronic Enthalpy (Ha)'],data['Vibrational Enthalpy (Ha)'],data['Translational Enthalpy (Ha)'],data['Rotational Enthalpy (Ha)']],  
            }
            pd.set_option("display.precision", 16)
            enerdf = pd.DataFrame(energy, index = ["Total","Electronic","Vibrational","Translational","Rotational"])
            
            entropy = {
                'Entropy (S - Ha/K)':[data['Entropy (Ha/K)'],data['Electronic Entropy (Ha/K)'],data['Vibrational Entropy (Ha/K)'],data['Translational Entropy (Ha/K)'],data['Rotational Entropy (Ha/K)']],
                'Helmholtz Free Entropy (Φ - Ha/K)':[data['Massieu Potential/Helmholtz Free Potential (Ha/K)'],data['Electronic Massieu Potential/Helmholtz Free Potential (Ha/K)'],data['Vibrational Massieu Potential/Helmholtz Free Potential (Ha/K)'],data['Translational Massieu Potential/Helmholtz Free Potential (Ha/K)'],data['Rotational Massieu Potential/Helmholtz Free Potential (Ha/K)']],
                'Gibbs Free Entropy (Ξ - Ha/K)':[data['Planck Potential/Gibbs Free Potential (Ha/K)'],data['Electronic Planck Potential/Gibbs Free Potential (Ha/K)'],data['Vibrational Planck Potential/Gibbs Free Potential (Ha/K)'],data['Translational Planck Potential/Gibbs Free Potential (Ha/K)'],data['Rotational Planck Potential/Gibbs Free Potential (Ha/K)']],
            }
            
            excluded_keys = ['Internal Energy (at given T) (Ha)', 'Electronic Internal Energy (Ha)', 'Vibrational Internal Energy (Ha)', 'Translational Internal Energy (Ha)', 'Rotational Internal Energy (Ha)', 'Helmholtz Free Energy (Ha)', 'Electronic Helmholtz Free Energy (Ha)', 'Vibrational Helmholtz Free Energy (Ha)', 'Translational Helmholtz Free Energy (Ha)', 'Rotational Helmholtz Free Energy (Ha)', 'Gibbs Free Energy (Ha)', 'Electronic Gibbs Free Energy (Ha)', 'Vibrational Gibbs Free Energy (Ha)', 'Translational Gibbs Free Energy (Ha)', 'Rotational Gibbs Free Energy (Ha)', 'Enthalpy (Ha)', 'Electronic Enthalpy (Ha)', 'Vibrational Enthalpy (Ha)', 'Translational Enthalpy (Ha)', 'Rotational Enthalpy (Ha)', 'Entropy (Ha/K)', 'Electronic Entropy (Ha/K)', 'Vibrational Entropy (Ha/K)', 'Translational Entropy (Ha/K)', 'Rotational Entropy (Ha/K)', 'Massieu Potential/Helmholtz Free Potential (Ha/K)', 'Electronic Massieu Potential/Helmholtz Free Potential (Ha/K)', 'Vibrational Massieu Potential/Helmholtz Free Potential (Ha/K)', 'Translational Massieu Potential/Helmholtz Free Potential (Ha/K)', 'Rotational Massieu Potential/Helmholtz Free Potential (Ha/K)', 'Planck Potential/Gibbs Free Potential (Ha/K)', 'Electronic Planck Potential/Gibbs Free Potential (Ha/K)', 'Vibrational Planck Potential/Gibbs Free Potential (Ha/K)', 'Translational Planck Potential/Gibbs Free Potential (Ha/K)', 'Rotational Planck Potential/Gibbs Free Potential (Ha/K)'] + ['Molecule', 'Rdkit Molecule', 'Basis', 'Molecule Name', 'Atoms', 'Bonds', 'Rings', 'Weight', 'Runtime', 'Hessian Runtime']
            
            pd.set_option("display.precision", 16)
            entrodf = pd.DataFrame(entropy, index = ["Total","Electronic","Vibrational","Translational","Rotational"])
            
            with st.expander():
                result_col_1, result_col_2 = st.columns([2, 1])
                result_col_1.write(
                    f"{data['Molecule Name']} | {data['Basis']} | Runtime: {data['Runtime']} seconds | Hessian Runtime: {data['Hessian Runtime']} seconds")
                result_col_1.write(
                    f"\# of Atoms: {data['Atoms']} | \# of Bonds: {data['Bonds']} | \# of Rings:  {data['Rings']}")
                result_col_1.write(
                    f"Molecular Weight: {data['Weight']}")
                # energy data
                for key, value in data.items():
                    if key not in excluded_keys:
                        result_col_1.write(f"{key}: {value}")

                with result_col_2:
                    speck_plot(
                        data['Molecule'], component_h=200, component_w=200, wbox_height="auto", wbox_width="auto")
                    st.image(Draw.MolToImage(data['Rdkit Molecule'], size=(200, 200)))
                    st.image(Draw.MolToImage(Chem.MolFromSmiles(data['Smiles']), size=(200, 200)))
                # linebreak
                st.write("")
                st.write("")
                st.table(data=enerdf)
                st.table(data=entrodf)
                

with tab2:
    # st.subheader("Comparative Graphs (WIP)")
    
    def count_atoms(molecule):
    # Check that there is a valid molecule
        if molecule:

            # Add hydrogen atoms--RDKit excludes them by default
            molecule_with_Hs = Chem.AddHs(molecule)
            comp = defaultdict(lambda: 0)

            # Get atom counts
            for atom in molecule_with_Hs.GetAtoms():
                comp[atom.GetAtomicNum()] += 1

            # # If charged, add charge as "atomic number" 0
            # charge = GetFormalCharge(molecule_with_Hs)
            # if charge != 0:
            #     comp[0] = charge
            return comp

    if 'results' in st.session_state and len(st.session_state['results']) > 1:
        st.subheader("Comparative Graphs")

        independent = [
            'Atoms',
            'Bonds',
            # 'Rings',
            'Weight',
        ]
        
        exclude = [
            'Basis',
            'Rings',
            'Rdkit Molecule',
            'Converged SCF-HF Electronic Energy (Ha)',
            'Molecule',
            'Molecule Name',
            'Smiles',
        ]
        
        dependent = [i for i in st.session_state['results'][0].keys() if i not in independent]
        dependent = [i for i in dependent if i not in exclude]
        # print(dependent)
        
        df_columns = list(st.session_state['results'][0].keys())
        df_columns.remove('Rdkit Molecule')
        
        df = pd.DataFrame(st.session_state['results'], columns=df_columns)
        
        
        for label in independent:
            for target in dependent:
                # print(label, target)
                # print(df[label].values, df[target].values)
                # Linear Regression
                coeffs_linear = np.polyfit(
                    df[label].values, df[target].values, 1)
                poly1d_fn_linear = np.poly1d(coeffs_linear)
                x = np.linspace(min(df[label]), max(df[label]), 100)

                # Quadratic Regression
                coeffs_quad = np.polyfit(
                    df[label].values, df[target].values, 2)
                poly1d_fn_quad = np.poly1d(coeffs_quad)
                
                # calculate R^2
                r2_linear = r2_score(df[target], poly1d_fn_linear(df[label]))
                r2_quad = r2_score(df[target], poly1d_fn_quad(df[label]))
                
                if r2_linear >= trend_threshold or r2_quad >= trend_threshold:
                    st.markdown(f'### Number of {label} vs. {target}')
                    # Display Equations
                    st.markdown(
                        f"<span style='color: red;'>Best Fit Linear Equation ({target}): Y = {coeffs_linear[0]:.4f}x + {coeffs_linear[1]:.4f} (R^2 = {r2_linear:.4f})</span>", unsafe_allow_html=True)
                    st.markdown(
                        f"<span style='color: green;'>Best Fit Quadratic Equation ({target}): Y = {coeffs_quad[0]:.4f}x² + {coeffs_quad[1]:.4f}x + {coeffs_quad[2]:.4f} (R^2 = {r2_quad:.4f})</span>", unsafe_allow_html=True)

                    # Create a DataFrame for the regression lines
                    df_line = pd.DataFrame(
                        {label: x, 'Linear': poly1d_fn_linear(x), 'Quadratic': poly1d_fn_quad(x)})

                    # Plot
                    scatter = alt.Chart(df).mark_circle(size=60).encode(
                        x=label,
                        y=target,
                        tooltip=[label, target]
                    )

                    line_linear = alt.Chart(df_line).mark_line(color='red').encode(
                        x=label,
                        y='Linear'
                    )

                    line_quad = alt.Chart(df_line).mark_line(color='green').encode(
                        x=label,
                        y='Quadratic'
                    )

                    # Display the plot
                    st.altair_chart(scatter + line_linear +
                                    line_quad, use_container_width=True)
        
        
        # for atomic_num, count in count_atoms(st.session_state['results'][0]['rdkit_mol']).items():
        
        # atom_counts = [count_atoms(result_item['rdkit_mol'])
        #                for result_item in st.session_state['results']]

        # # Prepare datasets
        # num_atoms = [result_item['atoms']
        #              for result_item in st.session_state['results']]
        # num_bonds = [result_item['bonds'].GetNumBonds()
        #              for result_item in st.session_state['results']]
        # num_conformers = [result_item[4].GetNumConformers()
        #                   for result_item in st.session_state['results']]
        # # 6 and 1 are atomic code
        # num_carbons = [atom_counts[i][6] for i in range(len(atom_counts))]
        # num_hydrogens = [atom_counts[i][1] for i in range(len(atom_counts))]

        # energies = [result_item[1]
        #             for result_item in st.session_state['results']]
        # runtimes = [result_item[2]
        #             for result_item in st.session_state['results']]

        # df_atoms = pd.DataFrame(
        #     {'Atoms': num_atoms, 'Energy': energies, 'Runtime': runtimes})
        # df_bonds = pd.DataFrame(
        #     {'Bonds': num_bonds, 'Energy': energies, 'Runtime': runtimes})
        # df_conformers = pd.DataFrame(
        #     {'Conformers': num_conformers, 'Energy': energies, 'Runtime': runtimes})
        # df_carbons = pd.DataFrame(
        #     {'Carbons': num_carbons, 'Energy': energies, 'Runtime': runtimes})
        # df_hydrogens = pd.DataFrame(
        #     {'Hydrogens': num_hydrogens, 'Energy': energies, 'Runtime': runtimes})

        # Generate Graphs
        # for df, label in zip([df_atoms, df_bonds, df_carbons, df_hydrogens], ['Atoms', 'Bonds', 'Carbons', 'Hydrogens']):
        #     for target in ['Energy', 'Runtime']:
        #         st.markdown(f'### Number of {label} vs. {target}')

        #         # Linear Regression
        #         coeffs_linear = np.polyfit(
        #             df[label].values, df[target].values, 1)
        #         poly1d_fn_linear = np.poly1d(coeffs_linear)
        #         x = np.linspace(min(df[label]), max(df[label]), 100)

        #         # Quadratic Regression
        #         coeffs_quad = np.polyfit(
        #             df[label].values, df[target].values, 2)
        #         poly1d_fn_quad = np.poly1d(coeffs_quad)

        #         # Display Equations
        #         st.markdown(
        #             f"<span style='color: red;'>Best Fit Linear Equation ({target}): Y = {coeffs_linear[0]:.4f}x + {coeffs_linear[1]:.4f}</span>", unsafe_allow_html=True)
        #         st.markdown(
        #             f"<span style='color: green;'>Best Fit Quadratic Equation ({target}): Y = {coeffs_quad[0]:.4f}x² + {coeffs_quad[1]:.4f}x + {coeffs_quad[2]:.4f}</span>", unsafe_allow_html=True)

        #         # Create a DataFrame for the regression lines
        #         df_line = pd.DataFrame(
        #             {label: x, 'Linear': poly1d_fn_linear(x), 'Quadratic': poly1d_fn_quad(x)})

        #         # Plot
        #         scatter = alt.Chart(df).mark_circle(size=60).encode(
        #             x=label,
        #             y=target,
        #             tooltip=[label, target]
        #         )

        #         line_linear = alt.Chart(df_line).mark_line(color='red').encode(
        #             x=label,
        #             y='Linear'
        #         )

        #         line_quad = alt.Chart(df_line).mark_line(color='green').encode(
        #             x=label,
        #             y='Quadratic'
        #         )

        #         # Display the plot
        #         st.altair_chart(scatter + line_linear +
        #                         line_quad, use_container_width=True)

        #     # Display Equation
        #     # st.write(f"Best Fit Equation ({target}): Y = {coeffs[0]:.4f}x + {coeffs[1]:.4f}")

with tab3:
    with open('output-test.txt', 'r') as file:
        log_data = file.read()
        st.markdown(f'```\n{log_data}\n```')


# xyzview = py3Dmol.view(query='pdb:1A2C')
# xyzview.setStyle({'cartoon':{'color':'spectrum'}})
# showmol(xyzview, height = 500,width=800)

# def draw_with_spheres(mol):
#     v = py3Dmol.view(width=300,height=300)
#     IPythonConsole.addMolToView(mol,v)
#     v.zoomTo()
#     v.setStyle({'sphere':{'radius':0.3},'stick':{'radius':0.2}});
#     v.show()


# Attempt at creating an async queue, need to find a way to detect browser closing to stop the queue

# def runQueue():
#     for i in range(1, 10):
#         time.sleep(1)
#         print("test", str(i))


# if 'queue-running' not in st.session_state:
#     st.session_state['queue-running'] = True
#     t = threading.Thread(target=runQueue)
#     add_script_run_ctx(t)
#     t.start()

# components.html("""<html>
# <script>
#     const origClose = window.close;
#     window.close = () => {
#         console.log("asdf");
#         // origClose();
#     }
#     document.addEventListener("beforeunload", () => {
#                 alert(1);
#                 console.log(a.a.a.a);
#     })
# </script>
# <div style="color: white" onclick="">
#                 hihihihi
# </div>
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Jaydens-MacBook.local', release='23.0.0', version='Darwin Kernel Version 23.0.0: Fri Sep 15 14:41:34 PDT 2023; root:xnu-10002.1.13~1/RELEASE_ARM64_T8103', machine='arm64', processor='arm')  Threads 1
Python 3.8.18 | packaged by conda-forge | (default, Oct 10 2023, 15:46:56) 
[Clang 16.0.6 ]
numpy 1.24.4  scipy 1.10.1
Date: Sun Jun 16 14:41:41 2024
PySCF version 2.4.0
PySCF path  /Users/jaydenl/anaconda3/envs/pyscfui/lib/python3.8/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 5
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 11
[INPUT] num. electrons = 26
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 C      0.000000000000   0.000000000000   0.583447000000 AA    0.000000000000   0.000000000000   1.102555038199 Bohr   0.0
[INPUT]  2 C      0.000000000000   1.271298000000  -0.258975000000 AA    0.000000000000   2.402405042707  -0.489391823109 Bohr   0.0
[INPUT]  3 C      0.000000000000  -1.271298000000  -0.258975000000 AA    0.000000000000  -2.402405042707  -0.489391823109 Bohr   0.0
[INPUT]  4 H      0.868757000000   0.000000000000   1.234855000000 AA    1.641712798799   0.000000000000   2.333537753550 Bohr   0.0
[INPUT]  5 H     -0.868757000000   0.000000000000   1.234855000000 AA   -1.641712798799   0.000000000000   2.333537753550 Bohr   0.0
[INPUT]  6 H      0.000000000000   2.157939000000   0.364822000000 AA    0.000000000000   4.077913703518   0.689413664216 Bohr   0.0
[INPUT]  7 H      0.000000000000  -2.157939000000   0.364822000000 AA    0.000000000000  -4.077913703518   0.689413664216 Bohr   0.0
[INPUT]  8 H      0.875817000000   1.315894000000  -0.898085000000 AA    1.655054265238   2.486679268958  -1.697134686580 Bohr   0.0
[INPUT]  9 H     -0.875817000000   1.315894000000  -0.898085000000 AA   -1.655054265238   2.486679268958  -1.697134686580 Bohr   0.0
[INPUT] 10 H     -0.875817000000  -1.315894000000  -0.898085000000 AA   -1.655054265238  -2.486679268958  -1.697134686580 Bohr   0.0
[INPUT] 11 H      0.875817000000  -1.315894000000  -0.898085000000 AA    1.655054265238  -2.486679268958  -1.697134686580 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] C
[INPUT] 0    0    [3    /1   ]  71.616837         0.15432897
                                13.045096         0.53532814
                                3.5305122         0.44463454
[INPUT] 0    0    [3    /1   ]  2.9412494         -0.09996723
                                0.6834831         0.39951283
                                0.2222899         0.70011547
[INPUT] 1    0    [3    /1   ]  2.9412494         0.15591627
                                0.6834831         0.60768372
                                0.2222899         0.39195739
[INPUT] H
[INPUT] 0    0    [3    /1   ]  3.42525091        0.15432897
                                0.62391373        0.53532814
                                0.1688554         0.44463454

nuclear repulsion = 82.8673336195195
number of shells = 17
number of NR pGTOs = 69
number of NR cGTOs = 23
basis = sto-3g
ecp = {}
CPU time:        12.71


******** <class 'pyscf.scf.uhf.UHF'> ********
method = UHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/_x/xd2ms3z958s6pfllwphw48vm0000gn/T/tmpzg7fanvo
max_memory 4000 MB (current use 0 MB)
number electrons alpha = 13  beta = 13
Set gradient conv threshold to 3.16228e-05
E1 = -312.61961598639186  Ecoul = 113.62946872640494
init E= -116.122813640467
cond(S) = 12.8938767786758
    CPU time for initialize scf      2.23 sec, wall time      0.31 sec
  alpha nocc = 13  HOMO = -0.553358250278145  LUMO = 0.262235220881772
  beta  nocc = 13  HOMO = -0.522027636175085  LUMO = 0.272837726255083
  alpha mo_energy =
[-11.38219787 -11.36653613 -11.36603334  -1.72299609  -1.39169371
  -1.12702727  -0.80131572  -0.75433604  -0.67920094  -0.64514896
  -0.57140197  -0.57080429  -0.55335825   0.26223522   0.29130551
   0.29396068   0.34843315   0.38691406   0.39300083   0.42756234
   0.43695405   0.45247249   0.47386663]
  beta  mo_energy =
[-11.38335197 -11.36834085 -11.36810538  -1.56950569  -1.29115114
  -1.05052619  -0.73468868  -0.69606123  -0.63396249  -0.60366068
  -0.53847724  -0.53701531  -0.52202764   0.27283773   0.29867676
   0.30483855   0.35889609   0.39379047   0.40288982   0.4357366
   0.44380154   0.45980048   0.48046652]
multiplicity <S^2> = 0.00017835924  2S+1 = 1.0003567
E1 = -322.0232001608997  Ecoul = 122.29821188491738
cycle= 1 E= -116.857654656463  delta_E= -0.735  |g|= 0.205  |ddm|= 2.55
    CPU time for cycle= 1      0.01 sec, wall time      0.00 sec
  alpha nocc = 13  HOMO = -0.393827591841803  LUMO = 0.655428797499413
  beta  nocc = 13  HOMO = -0.393565510109393  LUMO = 0.655491361040084
  alpha mo_energy =
[-10.95034965 -10.94633827 -10.9462576   -0.98101969  -0.86698315
  -0.74747909  -0.56929806  -0.53961116  -0.49350114  -0.47858458
  -0.40981477  -0.40411804  -0.39382759   0.6554288    0.66095928
   0.71216551   0.74810793   0.75077549   0.7966291    0.80700158
   0.82792104   0.82967808   0.8554346 ]
  beta  mo_energy =
[-10.95068311 -10.94662907 -10.94654841  -0.98121264  -0.86727715
  -0.74780613  -0.56887655  -0.53924585  -0.49332962  -0.47847528
  -0.4100939   -0.40410108  -0.39356551   0.65549136   0.66107044
   0.71239154   0.74750598   0.75101171   0.79583528   0.80598333
   0.82806879   0.82984854   0.85592514]
multiplicity <S^2> = 2.0838867e-05  2S+1 = 1.0000417
E1 = -320.67568058596817  Ecoul = 120.92364400910954
cycle= 2 E= -116.884702957339  delta_E= -0.027  |g|= 0.0388  |ddm|= 0.336
    CPU time for cycle= 2      0.02 sec, wall time      0.00 sec
  alpha nocc = 13  HOMO = -0.440270933854869  LUMO = 0.622550018860307
  beta  nocc = 13  HOMO = -0.440400483692203  LUMO = 0.622601753166667
  alpha mo_energy =
[-11.05263872 -11.04134901 -11.04127733  -1.02368173  -0.89820148
  -0.7758148   -0.6024021   -0.5737688   -0.52742765  -0.50832571
  -0.44635305  -0.44518817  -0.44027093   0.62255002   0.6239925
   0.66324269   0.71567156   0.71943578   0.76615287   0.77208259
   0.78585594   0.79677316   0.81693377]
  beta  mo_energy =
[-11.05267291 -11.0413416  -11.04127001  -1.02361601  -0.89816885
  -0.77586098  -0.60219765  -0.57358604  -0.52730544  -0.50825234
  -0.44635626  -0.44509984  -0.44040048   0.62260175   0.62394085
   0.66339009   0.71555572   0.71951206   0.76601061   0.77197091
   0.78585977   0.79671643   0.81717846]
multiplicity <S^2> = 6.3938833e-06  2S+1 = 1.0000128
E1 = -320.9075843495508  Ecoul = 121.15436658409874
cycle= 3 E= -116.885884145933  delta_E= -0.00118  |g|= 0.0093  |ddm|= 0.0612
    CPU time for cycle= 3      0.00 sec, wall time      0.00 sec
  alpha nocc = 13  HOMO = -0.437782242577659  LUMO = 0.627348452062907
  beta  nocc = 13  HOMO = -0.437860882442422  LUMO = 0.627309274140283
  alpha mo_energy =
[-11.04172327 -11.03233872 -11.03226641  -1.01789581  -0.89357188
  -0.77190385  -0.5994865   -0.57050617  -0.52422582  -0.50572241
  -0.4429664   -0.44123798  -0.43778224   0.62734845   0.62734871
   0.66890477   0.72017735   0.72259575   0.77218121   0.7755529
   0.79049007   0.8003595    0.82036026]
  beta  mo_energy =
[-11.04167345 -11.0322541  -11.03218188  -1.01776089  -0.89343817
  -0.77184272  -0.59943215  -0.57046016  -0.52419891  -0.50571071
  -0.44298188  -0.44121179  -0.43786088   0.62730927   0.62737114
   0.66899662   0.72021937   0.72263217   0.7722469    0.77556213
   0.79056659   0.80037787   0.82048817]
multiplicity <S^2> = 1.8141991e-06  2S+1 = 1.0000036
E1 = -320.88647779201165  Ecoul = 121.13319094285322
cycle= 4 E= -116.885953229639  delta_E= -6.91e-05  |g|= 0.000493  |ddm|= 0.0189
    CPU time for cycle= 4      0.01 sec, wall time      0.00 sec
  alpha nocc = 13  HOMO = -0.437758194300321  LUMO = 0.627312466979432
  beta  nocc = 13  HOMO = -0.437808264503507  LUMO = 0.62728828308381
  alpha mo_energy =
[-11.04206629 -11.03198486 -11.03191286  -1.01777472  -0.89339691
  -0.77180935  -0.59945884  -0.57044382  -0.52413252  -0.50559797
  -0.44291411  -0.4411566   -0.43775819   0.62731247   0.62734682
   0.6689278    0.72020338   0.72269256   0.77223933   0.77563747
   0.79053092   0.80029297   0.82039409]
  beta  mo_energy =
[-11.04204076 -11.03193312 -11.03186115  -1.01768605  -0.89330374
  -0.77176271  -0.59942713  -0.57041631  -0.5241169   -0.50559251
  -0.44292449  -0.44114022  -0.43780826   0.62728828   0.62735963
   0.66898294   0.72022813   0.72271542   0.77227508   0.77564508
   0.79057459   0.80030635   0.82046934]
multiplicity <S^2> = 6.9550359e-07  2S+1 = 1.0000014
E1 = -320.88594727516454  Ecoul = 121.13266012862181
cycle= 5 E= -116.885953527023  delta_E= -2.97e-07  |g|= 0.000261  |ddm|= 0.000864
    CPU time for cycle= 5      0.01 sec, wall time      0.00 sec
  alpha nocc = 13  HOMO = -0.437759790249707  LUMO = 0.62731122545513
  beta  nocc = 13  HOMO = -0.437782530563422  LUMO = 0.627299990448805
  alpha mo_energy =
[-11.04190052 -11.03206759 -11.0319955   -1.0177426   -0.89339246
  -0.771797    -0.59944926  -0.57044882  -0.52414052  -0.50561743
  -0.44290741  -0.44115011  -0.43775979   0.62731123   0.62735276
   0.66894922   0.72020764   0.72267857   0.77225763   0.77562181
   0.79054535   0.80031661   0.82043054]
  beta  mo_energy =
[-11.04189191 -11.03204263 -11.03197057  -1.01770514  -0.89334811
  -0.77177631  -0.59943623  -0.57043698  -0.52413353  -0.50561508
  -0.44291218  -0.44114217  -0.43778253   0.62729999   0.62735823
   0.66897421   0.72022166   0.72268935   0.77227276   0.77562733
   0.79056462   0.80032314   0.82046221]
multiplicity <S^2> = 1.4529239e-07  2S+1 = 1.0000003
E1 = -320.88597995852683  Ecoul = 121.13269269181973
cycle= 6 E= -116.885953647188  delta_E= -1.2e-07  |g|= 0.000119  |ddm|= 0.000673
    CPU time for cycle= 6      0.03 sec, wall time      0.01 sec
  alpha nocc = 13  HOMO = -0.437779100937476  LUMO = 0.627299495158916
  beta  nocc = 13  HOMO = -0.43778113942697  LUMO = 0.627298363996001
  alpha mo_energy =
[-11.04198162 -11.03201743 -11.03194539  -1.01773566  -0.89337029
  -0.77179493  -0.5994494   -0.5704414   -0.52413401  -0.50560881
  -0.44291784  -0.44115251  -0.4377791    0.6272995    0.62735217
   0.66895419   0.72021271   0.72269197   0.77226317   0.77563239
   0.79055576   0.80030769   0.82043655]
  beta  mo_energy =
[-11.04198413 -11.03201289 -11.03194086  -1.01773388  -0.89336275
  -0.77179383  -0.59944918  -0.57044081  -0.52413335  -0.5056083
  -0.4429181   -0.4411511   -0.43778114   0.62729836   0.62735252
   0.66895659   0.72021644   0.72269401   0.77226348   0.77563453
   0.79055714   0.80030822   0.82043772]
multiplicity <S^2> = 3.7040024e-09  2S+1 = 1
E1 = -320.8859989217291  Ecoul = 121.13271162428465
cycle= 7 E= -116.885953677925  delta_E= -3.07e-08  |g|= 1.91e-05  |ddm|= 0.000491
    CPU time for cycle= 7      0.02 sec, wall time      0.00 sec
  alpha nocc = 13  HOMO = -0.437778485908242  LUMO = 0.627301412924281
  beta  nocc = 13  HOMO = -0.437778151541043  LUMO = 0.627301659789899
  alpha mo_energy =
[-11.04196366 -11.03202065 -11.0319486   -1.01773057  -0.89336671
  -0.77179003  -0.59944543  -0.57043928  -0.52413337  -0.50560959
  -0.44291625  -0.44115018  -0.43777849   0.62730141   0.62735353
   0.66895726   0.72021357   0.72269077   0.77226179   0.77563069
   0.79055488   0.80031055   0.82043919]
  beta  mo_energy =
[-11.04196629 -11.03201921 -11.03194717  -1.01773163  -0.89336422
  -0.7717909   -0.59944604  -0.57043966  -0.52413346  -0.50560927
  -0.44291601  -0.44114987  -0.43777815   0.62730166   0.62735348
   0.66895698   0.72021469   0.72269166   0.77226093   0.77563143
   0.79055436   0.8003102    0.82043793]
multiplicity <S^2> = 8.2598994e-10  2S+1 = 1
E1 = -320.8859842911651  Ecoul = 121.13269699309339
cycle= 8 E= -116.885953678552  delta_E= -6.27e-10  |g|= 7.48e-06  |ddm|= 6.29e-05
    CPU time for cycle= 8      0.01 sec, wall time      0.00 sec
  alpha nocc = 13  HOMO = -0.437778524222578  LUMO = 0.627301509433565
  beta  nocc = 13  HOMO = -0.437778283724663  LUMO = 0.627301726607456
  alpha mo_energy =
[-11.04196476 -11.03202052 -11.03194848  -1.01773097  -0.89336667
  -0.77179048  -0.59944569  -0.5704396   -0.5241336   -0.50560966
  -0.44291634  -0.44115023  -0.43777852   0.62730151   0.62735352
   0.66895728   0.72021394   0.72269093   0.77226184   0.77563092
   0.79055482   0.80031065   0.82043903]
  beta  mo_energy =
[-11.04196661 -11.03201947 -11.03194743  -1.01773171  -0.89336491
  -0.77179117  -0.59944605  -0.57043982  -0.52413368  -0.5056094
  -0.44291618  -0.44115007  -0.43777828   0.62730173   0.62735354
   0.66895709   0.72021469   0.7226916    0.77226136   0.77563137
   0.79055449   0.80031037   0.82043822]
multiplicity <S^2> = 4.1870329e-10  2S+1 = 1
E1 = -320.88598626490307  Ecoul = 121.13269896675679
Extra cycle  E= -116.885953678627  delta_E= -7.46e-11  |g|= 5.27e-06  |ddm|= 1.21e-05
    CPU time for scf_cycle      2.38 sec, wall time      0.35 sec
    CPU time for SCF      2.39 sec, wall time      0.35 sec
converged SCF energy = -116.885953678627  <S^2> = 4.1870329e-10  2S+1 = 1
    CPU time for UHF partial hessian      2.97 sec, wall time      1.96 sec
    CPU time for UHF hessian      3.85 sec, wall time      2.44 sec
E1 = -320.88598626490307  Ecoul = 121.13269896675679
E1 = -320.88598626490307  Ecoul = 121.13269896675679
